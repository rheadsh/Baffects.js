<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\after-effects-shapes.js - baffects.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="baffects.js" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/b.html">b</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src\after-effects-shapes.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
ï»¿//Shapes

/**
 * Add a solid to the composition.
 * @cat AfterEffects
 * @subcat Shapes
 * @method solid
 * @param {String} [name] Name of the solid
 * @param {Number} x x-coordinate of the solid
 * @param {Number} y y-coordinate of the solid
 * @param {Number} [z] z-coordinate of the solid
 * @param {Number} w Width of the solid
 * @param {Number} h Height of the solid
 * @param {Number} [duration] Duration of the solid in seconds
 * @return {Properties} Properties object with attributes [layer, anchorpoint, position, xposition, yposition, zposition, scale, orientation, xrotation, yrotation, zrotation, rotation, opacity].
 *                      Each attribute is a Property object for convenience in animation, except of layer which is the new created solid AVLayer reference.
 *
 * &lt;h4&gt; Syntax: &lt;/h4&gt;
 * var solid = b.solid();                               &lt;br&gt;
 * var solid = b.solid(name);                           &lt;br&gt;
 * var solid = b.solid(duration);                       &lt;br&gt;
 * var solid = b.solid(x, y, w, h);                     &lt;br&gt;
 * var solid = b.solid(name, x, y, w, h);               &lt;br&gt;
 * var solid = b.solid(x, y, w, h, duration);           &lt;br&gt;
 * var solid = b.solid(x, y, z, w, h);                  &lt;br&gt;
 * var solid = b.solid(name, x, y, z, w, h);            &lt;br&gt;
 * var solid = b.solid(x, y, z, w, h, duration);        &lt;br&gt;
 */
pub.solid = function (name, x, y, z, w, h, dur) {
    var a = arguments[0],
        b = arguments[1],
        c = arguments[2],
        d = arguments[3],
        e = arguments[4],
        f = arguments[5],
        g = arguments[6];

    var newSolid;
    if (!curr3DMode) {
        switch (arguments.length) {
            case 0:
                newSolid = createSolid(thisComp, &quot;solid&quot;, pub.width / 2, pub.height / 2, 0, pub.width, pub.height, pub.getDuration());
                newSolid.name = &quot;solid_&quot; + (thisComp.numLayers).toString();
                return newSolid;
            case 1:
                if (typeof a === &quot;string&quot;) {
                    newSolid = createSolid(thisComp, a, pub.width / 2, pub.height / 2, 0, pub.width, pub.height, pub.getDuration());
                    return newSolid;
                } else {
                    newSolid = createSolid(thisComp, &quot;solid&quot;, pub.width / 2, pub.height / 2, 0, pub.width, pub.height, a);
                    newSolid.name = &quot;solid_&quot; + (thisComp.numLayers).toString();
                    return newSolid;
                }
            case 4:
                newSolid = createSolid(thisComp, &quot;solid&quot;, a, b, 0, c, d, pub.getDuration());
                newSolid.name = &quot;solid_&quot; + (thisComp.numLayers).toString();
                return newSolid;
            case 5:
                if (typeof a === &quot;string&quot;) {
                    newSolid = createSolid(thisComp, a, b, c, 0, d, e, pub.getDuration());
                    return newSolid;
                } else {
                    newSolid = createSolid(thisComp, &quot;solid&quot;, a, b, 0, c, d, e);
                    newSolid.name = &quot;solid_&quot; + (thisComp.numLayers).toString();
                    return newSolid;
                }
        }
    } else {
        switch (arguments.length) {
            case 5:
                newSolid = createSolid(thisComp, &quot;solid&quot;, a, b, c, d, e, pub.getDuration());
                newSolid.name = &quot;solid_&quot; + (thisComp.numLayers).toString();
                return newSolid;
            case 6:
                if (typeof a === &quot;string&quot;) {
                    newSolid = createSolid(thisComp, a, b, c, d, e, f, pub.getDuration());
                    return newSolid;
                } else {
                    newSolid = createSolid(thisComp, &quot;solid&quot;, a, b, c, d, e, f);
                    newSolid.name = &quot;solid_&quot; + (thisComp.numLayers).toString();
                    return newSolid;
                }
        }
    }
};

function createSolid(comp, name, x, y, z, w, h, dur) {
    this.obb = new Properties();

    this.shape = comp.layers.addSolid(currFillColor, name, w, h, 1, dur);
    this.obb.layer = this.shape;

    if (curr3DMode) {
        this.shape.threeDLayer = true;
    }

    setTransformPropertiesObject();

    pub.anchor(this.obb.layer, currAnchorMode);
    var cmx = currMatrix.position[0];
    var cmy = currMatrix.position[1];
    var cmz = currMatrix.position[2];
    this.obb.position.setValue([cmx + x, cmy + y, cmz + z]);

    this.obb.scale.setValue(currMatrix.scale);

    if (curr3DMode) {
        this.obb.xrotation.setValue(currMatrix.rotation3d[0]);
        this.obb.yrotation.setValue(currMatrix.rotation3d[1]);
        this.obb.zrotation.setValue(currMatrix.rotation3d[2]);
    } else {
        this.obb.rotation.setValue(currMatrix.rotation);
    }

    this.obb.opacity.setValue(currOpacity);

    this.shape.blendingMode = currBlendMode;

    return this.obb;
}

/**
 * Draws a rectangle to the composition.
 * @cat AfterEffects
 * @subcat Shapes
 * @method rect
 * @param {Number} x x-coordinate of the rectangle
 * @param {Number} y y-coordinate of the rectangle
 * @param {Number} [z] z-coordinate of the rectangle
 * @param {Number} w Width of the rectangle
 * @param {Number} h Height of the rectangle
 * @param {Number} [roundness] Roundness value of the rectangle
 * @return {Properties} Properties object with attributes [layer, anchorpoint, position, xposition, yposition, zposition, scale, orientation, xrotation, yrotation, zrotation, rotation, opacity, size, fill, stroke, weight, round].
 *                      Each attribute is a Property object for convenience in animation, except of layer which is the new created ShapeLayer reference.
 * 
 * &lt;h4&gt; Syntax: &lt;/h4&gt;
 * var rect = b.rect(x, y);                             &lt;br&gt;
 * var rect = b.rect(x, y, w, h);                       &lt;br&gt;
 * var rect = b.rect(x, y, w, h, roundness);            &lt;br&gt;
 * var rect = b.rect(x, y, z);                          &lt;br&gt;
 * var rect = b.rect(x, y, z, w, h);                    &lt;br&gt;
 * var rect = b.rect(x, y, z, w, h, roundness);         &lt;br&gt;
 */
pub.rect = function (x, y, z, w, h, round) {
    var a = arguments[0],
        b = arguments[1],
        c = arguments[2],
        d = arguments[3],
        e = arguments[4],
        f = arguments[5];

    var shape;
    if (!curr3DMode) {
        switch (arguments.length) {
            case 2:
                shape = drawRectShape(thisComp, a, b, 0, pub.width, pub.height, 0);
                return shape;
            case 4:
                shape = drawRectShape(thisComp, a, b, 0, c, d, 0);
                return shape;
            case 5:
                shape = drawRectShape(thisComp, a, b, 0, c, d, e);
                return shape;
        }
    } else {
        switch (arguments.length) {
            case 3:
                shape = drawRectShape(thisComp, a, b, c, pub.width, pub.height, 0);
                return shape;
            case 5:
                shape = drawRectShape(thisComp, a, b, c, d, e, 0);
                return shape;
            case 6:
                shape = drawRectShape(thisComp, a, b, c, d, e, f);
                return shape;
        }
    }
};

function drawRectShape(comp, x, y, z, w, h, round) {
    // Build Shape
    this.obb = new Properties();

    this.shape = comp.layers.addShape();
    this.obb.layer = shape;

    if (curr3DMode) {
        shape.threeDLayer = true;
    }

    this.shapeGroup = this.shape.property(&quot;ADBE Root Vectors Group&quot;).addProperty(&quot;ADBE Vector Group&quot;);
    this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Shape - Rect&quot;);

    if (currStrokeState) {
        createStroke();
    }

    if (currFillState) {
        createFill();
    }

    setTransformPropertiesObject();
    setStylePropertiesObject();
    this.obb.size = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).property(&quot;ADBE Vector Shape - Rect&quot;).property(&quot;ADBE Vector Rect Size&quot;);
    this.obb.round = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).property(&quot;ADBE Vector Shape - Rect&quot;).property(&quot;ADBE Vector Rect Roundness&quot;);

    // Set properties values on shape through Properies object
    this.obb.size.setValue([w, h]);
    this.obb.round.setValue(round);

    pub.anchor(this.obb.layer, currAnchorMode);
    var cmx = currMatrix.position[0];
    var cmy = currMatrix.position[1];
    var cmz = currMatrix.position[2];
    this.obb.position.setValue([cmx + x, cmy + y, cmz + z]);
    this.obb.scale.setValue(currMatrix.scale);

    if (curr3DMode) {
        this.obb.xrotation.setValue(currMatrix.rotation3d[0]);
        this.obb.yrotation.setValue(currMatrix.rotation3d[1]);
        this.obb.zrotation.setValue(currMatrix.rotation3d[2]);
    } else {
        this.obb.rotation.setValue(currMatrix.rotation);
    }

    this.obb.opacity.setValue(currOpacity);

    this.shape.blendingMode = currBlendMode;

    return this.obb;
}

/**
 * Draws an ellipse to the composition.
 * @cat AfterEffects
 * @subcat Shapes
 * @method ellipse
 * @param {Number} x x-coordinate of the ellipse
 * @param {Number} y y-coordinate of the ellipse
 * @param {Number} [z] z-coordinate of the ellipse
 * @param {Number} w Width of the ellipse
 * @param {Number} h Height of the ellipse
 * @return {Properties} Properties object with attributes [layer, anchorpoint, position, xposition, yposition, zposition, scale, orientation, xrotation, yrotation, zrotation, rotation, opacity, size, fill, stroke, weight].
 *                      Each attribute is a Property object for convenience in animation, except of layer which is the new created ShapeLayer reference.
 * 
 * &lt;h4&gt; Syntax: &lt;/h4&gt;
 * var ellipse = b.ellipse(x, y);                             &lt;br&gt;
 * var ellipse = b.ellipse(x, y, w, h);                       &lt;br&gt;
 * var ellipse = b.ellipse(x, y, z);                          &lt;br&gt;
 * var ellipse = b.ellipse(x, y, z, w, h);                    &lt;br&gt;
 */
pub.ellipse = function (x, y, z, w, h) {
    var a = arguments[0],
        b = arguments[1],
        c = arguments[2],
        d = arguments[3],
        e = arguments[4];

    var shape;
    if (!curr3DMode) {
        switch (arguments.length) {
            case 2:
                shape = drawEllipseShape(thisComp, a, b, 0, pub.width, pub.height);
                return shape;
            case 4:
                shape = drawEllipseShape(thisComp, a, b, 0, c, d);
                return shape;
        }
    } else {
        switch (arguments.length) {
            case 3:
                shape = drawEllipseShape(thisComp, a, b, c, pub.width, pub.height);
                return shape;
            case 5:
                shape = drawEllipseShape(thisComp, a, b, c, d, e);
                return shape;
        }
    }
};

function drawEllipseShape(comp, x, y, z, w, h) {
    // Build Shape
    this.obb = new Properties();

    this.shape = comp.layers.addShape();
    this.obb.layer = shape;

    if (curr3DMode) {
        shape.threeDLayer = true;
    }

    this.shapeGroup = this.shape.property(&quot;ADBE Root Vectors Group&quot;).addProperty(&quot;ADBE Vector Group&quot;);
    this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Shape - Ellipse&quot;);

    if (currStrokeState) {
        createStroke();
    }

    if (currFillState) {
        createFill();
    }

    setTransformPropertiesObject();
    setStylePropertiesObject();
    this.obb.size = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).property(&quot;ADBE Vector Shape - Ellipse&quot;).property(&quot;ADBE Vector Ellipse Size&quot;);

    // Set properties values on shape through Properies object
    this.obb.size.setValue([w, h]);

    pub.anchor(this.obb.layer, currAnchorMode);
    var cmx = currMatrix.position[0];
    var cmy = currMatrix.position[1];
    var cmz = currMatrix.position[2];
    this.obb.position.setValue([cmx + x, cmy + y, cmz + z]);
    this.obb.scale.setValue(currMatrix.scale);

    if (curr3DMode) {
        this.obb.xrotation.setValue(currMatrix.rotation3d[0]);
        this.obb.yrotation.setValue(currMatrix.rotation3d[1]);
        this.obb.zrotation.setValue(currMatrix.rotation3d[2]);
    } else {
        this.obb.rotation.setValue(currMatrix.rotation);
    }

    this.obb.opacity.setValue(currOpacity);

    this.shape.blendingMode = currBlendMode;

    return this.obb;
};

/**
 * Draws an n-gon to the composition.
 * @cat AfterEffects
 * @subcat Shapes
 * @method polygon
 * @param {Number} x x-coordinate of the polygon 
 * @param {Number} y y-coordinate of the polygon
 * @param {Number} [z] z-coordinate of the polygon 
 * @param {Number} r Radius of the polygon 
 * @param {Number} n Number of sides
 * @return {Properties} [layer, anchorpoint, position, xposition, yposition, zposition, scale, orientation, xrotation, yrotation, zrotation, rotation, opacity, points, radius, fill, stroke, weight].
 *                      Each attribute is a Property object for convenience in animation, except of layer which is the new created ShapeLayer reference.
 * 
 * &lt;h4&gt; Syntax: &lt;/h4&gt;
 * var polygon = b.polygon(x, y);                             &lt;br&gt;
 * var polygon = b.polygon(x, y, r, n);                       &lt;br&gt;
 * var polygon = b.ellipse(x, y, z);                          &lt;br&gt;
 */
pub.polygon = function (x, y, z, r, n) {
    var a = arguments[0],
        b = arguments[1],
        c = arguments[2],
        d = arguments[3],
        e = arguments[4];

    var shape;
    if (!curr3DMode) {
        switch (arguments.length) {
            case 2:
                shape = drawPolygonShape(thisComp, a, b, 0, pub.width, pub.height);
                return shape;
            case 4:
                shape = drawPolygonShape(thisComp, a, b, 0, c, d);
                return shape;
        }
    } else {
        switch (arguments.length) {
            case 3:
                shape = drawPolygonShape(thisComp, a, b, c, pub.width, pub.height);
                return shape;
            case 5:
                shape = drawPolygonShape(thisComp, a, b, c, d, e);
                return shape;
        }
    }
};

function drawPolygonShape(comp, x, y, z, r, n) {
    // Build Shape  
    this.obb = new Properties();

    this.shape = comp.layers.addShape();
    this.obb.layer = shape;
    if (curr3DMode) {
        this.shape.threeDLayer = true;
    }

    this.shapeGroup = this.shape.property(&quot;ADBE Root Vectors Group&quot;).addProperty(&quot;ADBE Vector Group&quot;);
    var gon = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Shape - Star&quot;);
    gon.property(&quot;ADBE Vector Star Type&quot;).setValue(2);

    if (currStrokeState) {
        createStroke();
    }

    if (currFillState) {
        createFill();
    }

    setTransformPropertiesObject();
    setStylePropertiesObject();
    this.obb.points = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).property(&quot;ADBE Vector Shape - Star&quot;).property(&quot;ADBE Vector Star Points&quot;);
    this.obb.radius = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).property(&quot;ADBE Vector Shape - Star&quot;).property(&quot;ADBE Vector Star Outer Radius&quot;);
    this.obb.roundness = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).property(&quot;ADBE Vector Shape - Star&quot;).property(&quot;ADBE Vector Star Outer Roundess&quot;);

    // Set properties values on shape through Properies object
    this.obb.points.setValue(n);
    this.obb.radius.setValue(r);

    pub.anchor(this.obb.layer, currAnchorMode);
    var cmx = currMatrix.position[0];
    var cmy = currMatrix.position[1];
    var cmz = currMatrix.position[2];
    this.obb.position.setValue([cmx + x, cmy + y, cmz + z]);
    this.obb.scale.setValue(currMatrix.scale);

    if (curr3DMode) {
        this.obb.xrotation.setValue(currMatrix.rotation3d[0]);
        this.obb.yrotation.setValue(currMatrix.rotation3d[1]);
        this.obb.zrotation.setValue(currMatrix.rotation3d[2]);
    } else {
        this.obb.rotation.setValue(currMatrix.rotation);
    }

    this.obb.opacity.setValue(currOpacity);

    this.shape.blendingMode = currBlendMode;

    return this.obb;
};

/**
 * Draws a line to the composition (currently only 2D mode supported).
 * @cat AfterEffects
 * @subcat Shapes
 * @method line
 * @param {Number} x1 x-coordinate of the first point 
 * @param {Number} y1 y-coordinate of the first point
 * @param {Number} x2 x-coordinate of the second point
 * @param {Number} y2 y-coordinate of the second point
 * @return {Properties} Properties object with attributes [layer, anchorpoint, position, xposition, yposition, zposition, scale, orientation, xrotation, yrotation, zrotation, rotation, opacity, stroke, weight].
 *                      Each attribute is a Property object for convenience in animation, except of layer which is the new created ShapeLayer reference.
 * @example
 * b.stroke(1);                                                            &lt;br&gt;
 * var line = b.line(0, 0, b.width, b.height);                             &lt;br&gt;
 */
pub.line = function (x1, y1, x2, y2) {
    var shape = drawLineShape(thisComp, x1, y1, x2, y2);
    return shape;
};

function drawLineShape(comp, x1, y1, x2, y2) {
    // Build Shape
    var fillState = currFillState;
    currFillState = false;
    this.obb = new Properties();

    this.shape = comp.layers.addShape();
    this.obb.layer = shape;

    if (curr3DMode) {
        this.shape.threeDLayer = true;
    }

    this.shapeGroup = this.shape.property(&quot;ADBE Root Vectors Group&quot;).addProperty(&quot;ADBE Vector Group&quot;);
    this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Shape - Group&quot;);

    createStroke();

    setTransformPropertiesObject();
    setStylePropertiesObject();
    this.obb.path = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).property(&quot;ADBE Vector Shape - Group&quot;).property(&quot;ADBE Vector Shape&quot;);

    // Set properties values on shape through Properies object
    var drawing = new Shape();
    drawing.vertices = [[x1, y1], [x2, y2]];
    this.obb.path.setValue(drawing);

    this.obb.stroke.setValue(currStrokeColor);

    this.obb.anchorpoint.setValue([x1, y1]);
    var cmx = currMatrix.position[0];
    var cmy = currMatrix.position[1];
    this.obb.position.setValue([cmx + x1, cmy + y1]);
    pub.anchor(this.obb.layer, currAnchorMode);

    this.obb.scale.setValue(currMatrix.scale);
    if (curr3DMode) {
        this.obb.xrotation.setValue(currMatrix.rotation3d[0]);
        this.obb.yrotation.setValue(currMatrix.rotation3d[1]);
        this.obb.zrotation.setValue(currMatrix.rotation3d[2]);
    } else {
        this.obb.rotation.setValue(currMatrix.rotation);
    }

    this.obb.opacity.setValue(currOpacity);

    this.shape.blendingMode = currBlendMode;

    currFillState = fillState;

    return this.obb;
};

/**
 * Draws a shape to the composition.
 * @cat AfterEffects
 * @subcat Shapes
 * @method shape
 * @param {Number[][]} vertices Shape vertices [x, y] array
 * @param {Number[][]} [inTangents] In tangents [x, y] array
 * @param {Number[][]} [outTangents] Out tangents [x, y] array
 * @param {Boolean} closed Open or closed shape
 * @return {Properties} Properties object with attributes [layer, anchorpoint, position, xposition, yposition, zposition, scale, orientation, xrotation, yrotation, zrotation, rotation, opacity, path, fill, stroke, weight].
 *                      Each attribute is a Property object for convenience in animation, except of layer which is the new created ShapeLayer reference.
 * @example
 * 
 * b.background(0);
 *   
 * var points = [];
 * var inTan = [];
 * var outTan = [];
 *   
 * for (var i=0; i&lt;20; i++) {
 *    var x = b.random(b.width);
 *    var y = b.random(b.height);
 *    points.push([x,y]);
 *    inTan.push([x-5, y-5]);
 *    outTan.push([x+5, y+5]);
 * }
 *   
 * b.stroke(1);
 * var mask = b.shape(points, inTan, outTan, false);
 * b.printProperties(mask);
 */
pub.shape = function (vertices, inTangents, outTangents, closed) {
    var a = arguments[0],
        b = arguments[1],
        c = arguments[2],
        d = arguments[3];

    var shape;
    switch (arguments.length) {
        case 1:
            shape = drawShape(thisComp, a, null, null, false);
            return shape;
        case 2:
            shape = drawShape(thisComp, a, null, null, b);
            return shape;
        case 3:
            shape = drawShape(thisComp, a, b, c, false);
            return shape;
        case 4:
            shape = drawShape(thisComp, a, b, c, d);
            return shape;
    }
};

function drawShape(comp, v, inTangents, outTangents, closed) {
    // Build Shape
    this.obb = new Properties();

    this.shape = comp.layers.addShape();
    this.obb.layer = shape;

    if (curr3DMode) {
        this.shape.threeDLayer = true;
    }

    this.shapeGroup = this.shape.property(&quot;ADBE Root Vectors Group&quot;).addProperty(&quot;ADBE Vector Group&quot;);
    this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Shape - Group&quot;);

    if (currStrokeState) {
        createStroke();
    }

    if (currFillState) {
        createFill();
    }

    setTransformPropertiesObject();
    setStylePropertiesObject();
    this.obb.path = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).property(&quot;ADBE Vector Shape - Group&quot;).property(&quot;ADBE Vector Shape&quot;);

    // Set properties values on shape through Properies object
    var drawing = new Shape();
    drawing.vertices = doTranslate(v);
    if (inTangents !== null) {
        drawing.inTangents = doTranslate(inTangents);
        drawing.outTangents = doTranslate(outTangents);
    }
    drawing.closed = closed;

    this.obb.path.setValue(drawing);

    this.obb.position.setValue([0, 0, 0]);

    pub.anchor(this.obb.layer, currAnchorMode);

    this.obb.scale.setValue(currMatrix.scale);

    if (curr3DMode) {
        this.obb.xrotation.setValue(currMatrix.rotation3d[0]);
        this.obb.yrotation.setValue(currMatrix.rotation3d[1]);
        this.obb.zrotation.setValue(currMatrix.rotation3d[2]);
    } else {
        this.obb.rotation.setValue(currMatrix.rotation);
    }

    this.obb.opacity.setValue(currOpacity);

    this.shape.blendingMode = currBlendMode;

    if (pub.INACTIVE) {
        this.obb.layer.enabled = false;
    }

    return this.obb;
};

var doTranslate = function (points) {
    var newPoints = [];
    if (points[0].length === 2) {
        for (var i = 0; i &lt; points.length; i++) {
            var temp = [];
            temp[0] = points[i][0] + currMatrix.position[0];
            temp[1] = points[i][1] + currMatrix.position[1];
            newPoints.push(temp);
        }
    } else {
        for (var i = 0; i &lt; points.length; i++) {
            var temp = [];
            temp[0] = points[i][0] + currMatrix.position[0];
            temp[1] = points[i][1] + currMatrix.position[1];
            temp[2] = points[i][2] + currMatrix.position[2];
            newPoints.push(temp);
        }
    }
    return newPoints;
};

/**
 * Creates a new null object.
 * @cat AfterEffects
 * @subcat Shapes
 * @method nullLayer
 * @param {Number} [duration] Duration in seconds of null object
 * @return {Properties} Properties object with attributes [layer, anchorpoint, position, xposition, yposition, zposition, scale, orientation, xrotation, yrotation, zrotation, rotation, opacity].
 *                      Each attribute is a Property object for convenience in animation, except of layer which is the new created ShapeLayer reference.
 * 
 * &lt;h4&gt; Syntax: &lt;/h4&gt;
 * var null = b.nullLayer();                &lt;/br&gt;
 * var null = b.nullLayer(duration);        &lt;/br&gt;
 */
pub.nullLayer = function (duration) {
    var a = arguments[0],
        b = arguments[1];

    var nullObject;
    switch (arguments.length) {
        case 0:
            nullObject = createNullObject(thisComp, pub.getDuration());
            return nullObject;
        case 1:
            nullObject = createNullObject(thisComp, a);;
            return nullObject;
    }
}

function createNullObject(comp, duration) {
    this.obb = new Properties();
    this.shape = comp.layers.addNull(duration);
    this.obb.layer = this.shape;

    if (curr3DMode) {
        nullObject.threeDLayer = true;
    }
    setTransformPropertiesObject();

    return this.obb;
}















//BeginShape and EndShape implementation for AE
var vertix = [];
var inTan = [];
var outTan = [];
var currDrawingMode = 0;
var styleStack = [];
var Style = function (fs, f, ss, s, w) {
    this.fillState = fs;
    this.fill = f;
    this.strokeState = ss;
    this.stroke = s;
    this.weight = w;
};

/**
 * Using the beginShape() and endShape() functions allow creating more complex forms. beginShape() begins recording vertices for a shape and endShape() stops recording. 
 * The value of the kind parameter tells it which types of shapes to create from the provided vertices. With no mode specified, the shape can be any irregular polygon. 
 * The parameters available for beginShape() are LINES, TRIANGLES, QUADS. 
 * After calling the beginShape() function, a series of vertex(), itangent() or otangent() commands must follow. To stop drawing the shape, call endShape(). 
 * Each shape will be outlined with the current stroke color and filled with the fill color. 
 * @method beginShape
 * @param {NONE|LINES|QUADS|TRIANGLES|INVISIBLE} mode 
 */
pub.beginShape = function (mode) {
    styleStack = [];
    if (arguments.length === 1) {
        if (mode === pub.INACTIVE) {
            pub.INACTIVE = true;
            currDrawingMode = 0;
            return false;
        }
        currDrawingMode = mode;
    }
}

/**
 * The endShape() function is the companion to beginShape() and may only be called after beginShape(). 
 * When endshape() is called, all of image data defined since the previous call to beginShape() is written into the image buffer. 
 * The constant CLOSE as the value for the MODE parameter to close the shape (to connect the beginning and the end).
 * @method endShape
 * @param {NONE|CLOSE} close 
 */
pub.endShape = function (close) {
    var isClosed = false;
    if (arguments.length === 1) {
        if (close === pub.CLOSE) {
            isClosed = true;
        }
    }
    lastShapes = [];
    var shape;
    switch (currDrawingMode) {
        case 0:
            if (inTan.length &gt; 0 &amp;&amp; outTan.length &gt; 0) {
                shape = drawShape(thisComp, vertix, inTan, outTan, isClosed);
            } else if (inTan.length &gt; 0) {
                shape = drawShape(thisComp, vertix, inTan, inTan, isClosed);
            } else {
                shape = drawShape(thisComp, vertix, null, null, isClosed);
            }
            break;
        case 1:
            if (vertix.length % 2 === 0) {
                shape = createShapeWithLines(thisComp, vertix, null, null, isClosed, 2);
                break;
            } else {
                error(&quot;Bad number of vertex points for this drawing mode&quot;);
                break;
            }

        case 2:
            if (vertix.length % 4 === 0) {
                shape = createShapeWithLines(thisComp, vertix, null, null, isClosed, 4);
                break;
            } else {
                error(&quot;Bad number of vertex points for this drawing mode&quot;);
                break;
            }

        case 3:
            if (vertix.length % 3 === 0) {
                shape = createShapeWithLines(thisComp, vertix, null, null, isClosed, 3);
                break;
            } else {
                error(&quot;Bad number of vertex points for this drawing mode&quot;);
                break;
            }
    }
    vertix = [];
    inTan = [];
    outTan = [];
    pub.INACTIVE = false;
    return shape;
};

/**
 * All shapes are constructed by connecting a series of vertices. vertex() is used to specify the vertex coordinates for lines, triangles, quads, and polygons. 
 * It is used exclusively within the beginShape() and endShape() functions. 
 * @method vertex
 * @param {Number} x x-coordinate of the vertex
 * @param {Number} y y-coordinate of the vertex
 */
pub.vertex = function (x, y) {
    vertix.push([x, y]);
}

/**
 * Define in tangents for shape. Transformation space is relative to the vertex() defined.
 * @method itangent
 * @param {Number} x  x-coordinate of the vertex
 * @param {Number} y  y-coordinate of the vertex
 */
pub.itangent = function (x, y) {
    inTan.push([x, y]);
}

/**
 * Define out tangents for shape. Transformation space is relative to the vertex() defined.
 * @method otangent
 * @param {Number} x  x-coordinate of the vertex 
 * @param {Number} y  y-coordinate of the vertex 
 */
pub.otangent = function (x, y) {
    outTan.push([x, y]);
}


var lastShapes = [];

function createShapeWithLines(comp, v, inTangents, outTangents, closed, inc) {
    this.obb = new Properties();

    this.shape = comp.layers.addShape();
    this.obb.layer = shape;

    if (curr3DMode) {
        this.shape.threeDLayer = true;
    }

    var generalGroup = this.shape.property(&quot;ADBE Root Vectors Group&quot;).addProperty(&quot;ADBE Vector Group&quot;);

    if (inc === 2) {
        var group = 1;
        for (var i = 0; i &lt; v.length; i += inc) {
            this.lastShapesProps = new Properties();

            var shapeGroup = generalGroup.property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Group&quot;);
            var line = shapeGroup.property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Shape - Group&quot;);

            var drawing = new Shape();
            var cmx = currMatrix.position[0];
            var cmy = currMatrix.position[1];
            drawing.vertices = [cmx + v[i], cmy + v[i + 1]];
            line.property(&quot;ADBE Vector Shape&quot;).setValue(drawing);

            createStroke();
        }
    }

    if (inc === 4 || inc === 3) {
        for (var i = 0; i &lt; v.length; i += inc) {
            this.lastShapesProps = new Properties();

            this.shapeGroup = generalGroup.property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Group&quot;);
            var line = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Shape - Group&quot;);
            var drawing = new Shape();
            drawing.vertices = doTranslate(v.slice(i, i + inc));
            line.property(&quot;ADBE Vector Shape&quot;).setValue(drawing);

            if (currStrokeState) {
                createStroke();
            }

            if (currFillState) {
                createFill();
            }
        }
    }

    buildLastShapeProperties(generalGroup);


    setTransformPropertiesObject();

    this.obb.position.setValue([0, 0, 0]);

    pub.anchor(this.obb.layer, currAnchorMode);

    if (matrixStack.length &gt; 0) {
        var cmx = currMatrix.position[0];
        var cmy = currMatrix.position[1];
        var cmz = currMatrix.position[2];
        this.obb.position.setValue([cmx, cmy, cmz]);
    }

    this.obb.scale.setValue(currMatrix.scale);

    if (curr3DMode) {
        this.obb.xrotation.setValue(currMatrix.rotation3d[0]);
        this.obb.yrotation.setValue(currMatrix.rotation3d[1]);
        this.obb.zrotation.setValue(currMatrix.rotation3d[2]);
    } else {
        this.obb.rotation.setValue(currMatrix.rotation);
    }

    this.obb.opacity.setValue(currOpacity);

    this.shape.blendingMode = currBlendMode;

    return this.obb;
}

function buildLastShapeProperties(group) {
    var allGroup = group.property(&quot;ADBE Vectors Group&quot;);
    for (var i = 0; i &lt; allGroup.numProperties; i++) {
        var shapeProps = new Properties();
        var interiorGroup = allGroup.property(i + 1).property(&quot;ADBE Vectors Group&quot;);
        checkStyleStack(i);

        if (currStrokeState) {
            shapeProps.stroke = interiorGroup.property(&quot;ADBE Vector Graphic - Stroke&quot;).property(&quot;ADBE Vector Stroke Color&quot;);
            shapeProps.weight = interiorGroup.property(&quot;ADBE Vector Graphic - Stroke&quot;).property(&quot;ADBE Vector Stroke Width&quot;);
            shapeProps.linecap = interiorGroup.property(&quot;ADBE Vector Graphic - Stroke&quot;).property(&quot;ADBE Vector Stroke Line Cap&quot;);
            shapeProps.linejoin = interiorGroup.property(&quot;ADBE Vector Graphic - Stroke&quot;).property(&quot;ADBE Vector Stroke Line Join&quot;);
            shapeProps.miterlimit = interiorGroup.property(&quot;ADBE Vector Graphic - Stroke&quot;).property(&quot;ADBE Vector Stroke Miter Limit&quot;);
            shapeProps.stroke.setValue(currStrokeColor);
            shapeProps.weight.setValue(currStrokeWeight);
        }

        if (currFillState) {
            shapeProps.fill = interiorGroup.property(&quot;ADBE Vector Graphic - Fill&quot;).property(&quot;ADBE Vector Fill Color&quot;);
            shapeProps.fill.setValue(currFillColor);
        }

        var transform = allGroup.property(i + 1).property(&quot;ADBE Vector Transform Group&quot;);
        for (var k = 0; k &lt; transform.numProperties; k++) {
            shapeProps[transform.property(k + 1).name.toLowerCase().replace(/\s/g, &#x27;&#x27;)] = transform.property(k + 1);
        }

        lastShapes.push(shapeProps);
    }
}

function checkStyleStack(group) {
    if (group &lt; styleStack.length) {
        currFillState = styleStack[group].fillState;
        currFillColor = styleStack[group].fill;
        currStrokeState = styleStack[group].strokeState;
        currStrokeColor = styleStack[group].stroke;
        currStrokeWeight = styleStack[group].weight;
    }
}

function setLastShapeStyles() {
    for (var i = 0; i &lt; lastShapes.length; i++) {
        checkStyleStack(i);
        if (currStrokeState) {
            lastShapes[i].stroke.setValue(currStrokeColor);
            lastShapes[i].weight.setValue(currStrokeWeight);
        }

        if (currFillState) {
            lastShapes[i].fill.setValue(currFillColor);
        }
    }
}

/**
 * Return individual properties of the last shape drawn with beginShape() and endShape().
 * @method lastShape
 * @return {Properties} Array of Properties for individual shapes;
 */
pub.lastShape = function () {
    return lastShapes;
}






//Creating stroke and fill 
function createStroke() {
    var strokeHere = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Graphic - Stroke&quot;);
    switch (currCaps) {
        case 0:
            strokeHere.property(&quot;ADBE Vector Stroke Line Cap&quot;).setValue(1);
            break;
        case 1:
            strokeHere.property(&quot;ADBE Vector Stroke Line Cap&quot;).setValue(2);
            break;
        case 2:
            strokeHere.property(&quot;ADBE Vector Stroke Line Cap&quot;).setValue(3);
            break;
    }
};

function createFill() {
    this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Graphic - Fill&quot;);
};

// Get all transform properties for shapes
function setTransformPropertiesObject() {
    var transform = this.shape.property(&quot;ADBE Transform Group&quot;);
    for (var i = 0; i &lt; transform.numProperties - 1; i++) {
        this.obb[transform.property(i + 1).name.toLowerCase().replace(/\s/g, &#x27;&#x27;)] = transform.property(i + 1);
    }
}

//Recover properties of created shape layer
function setStylePropertiesObject() {
    if (currStrokeState) {
        this.obb.stroke = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).property(&quot;ADBE Vector Graphic - Stroke&quot;).property(&quot;ADBE Vector Stroke Color&quot;);
        this.obb.weight = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).property(&quot;ADBE Vector Graphic - Stroke&quot;).property(&quot;ADBE Vector Stroke Width&quot;);
        this.obb.stroke.setValue(currStrokeColor);
        this.obb.weight.setValue(currStrokeWeight);
    }

    if (currFillState) {
        this.obb.fill = this.shapeGroup.property(&quot;ADBE Vectors Group&quot;).property(&quot;ADBE Vector Graphic - Fill&quot;).property(&quot;ADBE Vector Fill Color&quot;);
        this.obb.fill.setValue(currFillColor);
    }
}



































//______________________________________________________________________________________________________________________
// ShapeLayer FX

/**
 * Add Pucker &amp; Bloat effect to ShapeLayer.
 * @cat AfterEffects
 * @subcat Shapes
 * @method shapePuckerBloat
 * @param {ShapeLayer} shape ShapeLayer or Properties object to add effect to
 * @return {Properties} Properties object with attributes [amount].
 * @example
 * var shape = b.rect(b.width / 2, b.height / 2, 400, 400);         &lt;br&gt;
 * var fx = b.shapePuckerBloat(shape.layer);                        &lt;br&gt;
 */
pub.shapePuckerBloat = function (rShape) {
    var shape;
    if (validateLayer(rShape, ShapeLayer)) {
        shape = rShape;
    } else {
        shape = rShape.layer;
    }

    var obb = new Properties();
    var pb = shape.property(&quot;ADBE Root Vectors Group&quot;).property(1).property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Filter - PB&quot;);
    obb.amount = pb.property(&quot;ADBE Vector PuckerBloat Amount&quot;);

    return obb;
};

/**
 * Add Repeater effects to ShapeLayer.
 * @cat AfterEffects
 * @subcat Shapes
 * @method shapeRepeater
 * @param {ShapeLayer} shape ShapeLayer or Properties object to add effect to
 * @return {Properties} Properties object with attributes [copies, offset, composite, anchor, position, scale, rotation, startopacity, endopacity].
 * @example
 * var shape = b.rect(b.width / 2, b.height / 2, 400, 400);         &lt;br&gt;
 * var fx = b.shapeRepeater(shape.layer);                           &lt;br&gt;
 */
pub.shapeRepeater = function (rShape) {
    var shape;
    if (validateLayer(rShape, ShapeLayer)) {
        shape = rShape;
    } else {
        shape = rShape.layer;
    }

    var obb = new Properties();
    var repeater = shape.property(&quot;ADBE Root Vectors Group&quot;).property(1).property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Filter - Repeater&quot;);
    obb.copies = repeater.property(&quot;ADBE Vector Repeater Copies&quot;);
    obb.offset = repeater.property(&quot;ADBE Vector Repeater Offset&quot;);
    obb.composite = repeater.property(&quot;ADBE Vector Repeater Order&quot;);

    var transform = repeater.property(&quot;ADBE Vector Repeater Transform&quot;);
    for (var i = 0; i &lt; transform.numProperties; i++) {
        obb[transform.property(i + 1).name.toLowerCase().replace(/\s/g, &#x27;&#x27;)] = transform.property(i + 1);
    }

    return obb;
};

/**
 * Add Trim Paths effect to ShapeLayer.
 * @cat AfterEffects
 * @subcat Shapes
 * @method shapeTrimPaths
 * @param {ShapeLayer} shape ShapeLayer or Properties object to add effect to
 * @return {Properties} Properties object with attributes [start, end, offset].
 * @example
 * var shape = b.rect(b.width / 2, b.height / 2, 400, 400);         &lt;br&gt;
 * var fx = b.shapeTrimPaths(shape.layer);                          &lt;br&gt;
 */
pub.shapeTrimPaths = function (rShape) {
    var shape;
    if (validateLayer(rShape, ShapeLayer)) {
        shape = rShape;
    } else {
        shape = rShape.layer;
    }

    var obb = new Properties();
    var trim = shape.property(&quot;ADBE Root Vectors Group&quot;).property(1).property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Filter - Trim&quot;);
    obb.start = trim.property(&quot;ADBE Vector Trim Start&quot;);
    obb.end = trim.property(&quot;ADBE Vector Trim End&quot;);
    obb.offset = trim.property(&quot;ADBE Vector Trim Offset&quot;);

    return obb;
};

/**
 * Add Twist effect to ShapeLayer.
 * @cat AfterEffects
 * @subcat Shapes
 * @method shapeTwist
 * @param {ShapeLayer} shape ShapeLayer or Properties object to add effect to
 * @return {Properties} Properties object with attributes [angle, center].
 * @example
 * var shape = b.rect(b.width / 2, b.height / 2, 400, 400);         &lt;br&gt;
 * var fx = b.shapeTwist(shape.layer);                              &lt;br&gt;
 */
pub.shapeTwist = function (rShape) {
    var shape;
    if (validateLayer(rShape, ShapeLayer)) {
        shape = rShape;
    } else {
        shape = rShape.layer;
    }

    var obb = new Properties();
    var twist = shape.property(&quot;ADBE Root Vectors Group&quot;).property(1).property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Filter - Twist&quot;);
    obb.angle = twist.property(&quot;ADBE Vector Twist Angle&quot;);
    obb.center = twist.property(&quot;ADBE Vector Twist Center&quot;);

    return obb;
};

/**
 * Add Wiggle Path effect to ShapeLayer.
 * @cat AfterEffects
 * @subcat Shapes
 * @method shapeWigglePaths
 * @param {ShapeLayer} shape ShapeLayer or Properties object to add effect to
 * @return {Properties} Properties object with attributes [size, detail, points, wiggles, correlation, temporalphase, spatialphase, seed].
 * @example
 * var shape = b.rect(b.width / 2, b.height / 2, 400, 400);         &lt;br&gt;
 * var fx = b.shapeWigglePaths(shape.layer);                        &lt;br&gt;
 */
pub.shapeWigglePaths = function (rShape) {
    var shape;
    if (validateLayer(rShape, ShapeLayer)) {
        shape = rShape;
    } else {
        shape = rShape.layer;
    }

    var obb = new Properties();
    var wiggle = shape.property(&quot;ADBE Root Vectors Group&quot;).property(1).property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Filter - Roughen&quot;);
    obb.size = wiggle.property(&quot;ADBE Vector Roughen Size&quot;);
    obb.detail = wiggle.property(&quot;ADBE Vector Roughen Detail&quot;);
    obb.points = wiggle.property(&quot;ADBE Vector Roughen Points&quot;);
    obb.wiggles = wiggle.property(&quot;ADBE Vector Temporal Freq&quot;);
    obb.correlation = wiggle.property(&quot;ADBE Vector Correlation&quot;);
    obb.temporalphase = wiggle.property(&quot;ADBE Vector Temporal Phase&quot;);
    obb.spatialphase = wiggle.property(&quot;ADBE Vector Spatial Phase&quot;);
    obb.seed = wiggle.property(&quot;ADBE Vector Random Seed&quot;);

    return obb;
};


/**
 * Add Wiggle Transform effect to ShapeLayer.
 * @cat AfterEffects
 * @subcat Shapes
 * @method shapeWiggleTransform
 * @param {ShapeLayer} shape ShapeLayer or Properties object to add effect to
 * @return {Properties} Properties object with attributes [wiggles, correlation, temporalphase, spatialphase, seed, anchor, position, scale, rotation].
 * @example
 * var shape = b.rect(b.width / 2, b.height / 2, 400, 400);         &lt;br&gt;
 * var fx = b.shapeWiggleTransform(shape.layer);                    &lt;br&gt;
 */
pub.shapeWiggleTransform = function (rShape) {
    var shape;
    if (validateLayer(rShape, ShapeLayer)) {
        shape = rShape;
    } else {
        shape = rShape.layer;
    }

    var obb = new Properties();
    var wiggle = shape.property(&quot;ADBE Root Vectors Group&quot;).property(1).property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Filter - Wiggler&quot;);
    obb.wiggles = wiggle.property(&quot;ADBE Vector Xform Temporal Freq&quot;);
    obb.correlation = wiggle.property(&quot;ADBE Vector Correlation&quot;);
    obb.temporalphase = wiggle.property(&quot;ADBE Vector Temporal Phase&quot;);
    obb.spatialphase = wiggle.property(&quot;ADBE Vector Spatial Phase&quot;);
    obb.seed = wiggle.property(&quot;ADBE Vector Random Seed&quot;);

    var transform = wiggle.property(&quot;ADBE Vector Wiggler Transform&quot;);
    for (var i = 0; i &lt; transform.numProperties; i++) {
        obb[transform.property(i + 1).name.toLowerCase().replace(/\s/g, &#x27;&#x27;)] = transform.property(i + 1);
    }

    return obb;
};

/**
 * Add Zig Zag effect to ShapeLayer.
 * @cat AfterEffects
 * @subcat Shapes
 * @method shapeZigZag
 * @param {ShapeLayer} shape ShapeLayer or Properties object to add effect to
 * @return {Properties} Properties object with attributes [size, ridges, points].
 * @example
 * var shape = b.rect(b.width / 2, b.height / 2, 400, 400);         &lt;br&gt;
 * var fx = b.shapeZigZag(shape.layer);                             &lt;br&gt;
 */
pub.shapeZigZag = function (rShape) {
    var shape;
    if (validateLayer(rShape, ShapeLayer)) {
        shape = rShape;
    } else {
        shape = rShape.layer;
    }

    var obb = new Properties();
    var zz = shape.property(&quot;ADBE Root Vectors Group&quot;).property(1).property(&quot;ADBE Vectors Group&quot;).addProperty(&quot;ADBE Vector Filter - Zigzag&quot;);
    obb.size = zz.property(&quot;ADBE Vector Zigzag Size&quot;);
    obb.ridges = zz.property(&quot;ADBE Vector Zigzag Detail&quot;);
    obb.points = zz.property(&quot;ADBE Vector Zigzag Points&quot;);

    return obb;
};



//Has not yet being implemented on AE API 
// pub.paint = function(points) {
//     this.obb = new Properties();
//     var solid = pub.solid();
// 	var paint = solid.layer.effect.addProperty(&quot;ADBE Paint&quot;);
//     var brush = paint.property(&quot;ADBE Paint Group&quot;).addProperty(&quot;ADBE Paint Atom&quot;);

//     this.obb.layer = solid.layer;
//     this.obb.path = brush.property(&quot;ADBE Paint Shape&quot;);

//     var shape = new Shape();
//     shape.vertices = points;
//     // this.obb.path.setValue(shape);
//     solid.layer.property(&quot;ADBE Effect Parade&quot;).property(&quot;ADBE Paint&quot;).property(&quot;ADBE Paint Group&quot;).property(&quot;ADBE Paint Atom&quot;).property(&quot;ADBE Paint Shape&quot;).setValue(shape);

//     var strokeProps = brush.property(&quot;ADBE Paint Properties&quot;);
//     for (var i = 0; i &lt; strokeProps.numProperties - 1; i++) {
//         this.obb[strokeProps.property(i + 1).name.toLowerCase().replace(/\s/g, &#x27;&#x27;)] = strokeProps.property(i + 1);
//     }

//     return this.obb;
// };
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
